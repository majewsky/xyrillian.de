<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Liste von Listen - Xyrillian Noises</title>
  <link rel="stylesheet" href="/res/xyrillian.css" />
</head>
<body class="noises episode-stp has-nav-top-card">
  <nav class="top-card">
    <div>
      <a href="/noises/">
        <img class="sitelogo" src="/res/logo-noises.svg" alt="Xyrillian Noises Hörfunkproduktion">
      </a>
    </div>
  </nav>
  <header>
    <a class="coverart" href="/noises/stp/">
      <img src="/res/cover-stp.svg" alt="Cover-Art für: Schlüsseltechnologie">
    </a>
    <h2><a href="/noises/stp">Schlüsseltechnologie</a> #77 vom 21. August 2025</h2>
    <h1>Liste von Listen</h1>
      <p>Als der inoffizielle Wikipedia-Vorlesepodcast sehen wir es als unsere Pflicht, eine Eigenheit dieser anzusprechen: nämlich Listen von Listen, obwohl es uns eigentlich um Listen im Speicher geht.</p>
      <p><strong>Länge:</strong> 57:06 Minuten</p>
  </header>
    <audio controls preload="none">
        <source src="/dl/stp-077-liste-von-listen.mp3" type="audio/mpeg">
        <source src="/dl/stp-077-liste-von-listen.ogg" type="audio/ogg">
        <source src="/dl/stp-077-liste-von-listen.opus" type="audio/opus">
      <div class="audio-not-supported">
        <span>Webplayer nicht vom Browser unterstützt</span>
      </div>
    </audio>
    <div id="chapters">
      <div class="chapter" data-start="0" data-end="232">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">00:00</span>
        <span class="chapter-title">Post aus dem Land der Dänen</span>
      </div>
      <div class="chapter" data-start="232" data-end="394">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">03:52</span>
        <span class="chapter-title">Intro und tote Staatsoberhäupter</span>
      </div>
      <div class="chapter" data-start="394" data-end="911">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">06:34</span>
        <span class="chapter-title">Rückbezüge zu STP071</span>
      </div>
      <div class="chapter" data-start="911" data-end="1583">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">15:11</span>
        <span class="chapter-title">Verkettete Listen</span>
      </div>
      <div class="chapter" data-start="1583" data-end="2261">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">26:23</span>
        <span class="chapter-title">Balancierte Bäume</span>
      </div>
      <div class="chapter" data-start="2261" data-end="2531">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">37:41</span>
        <span class="chapter-title">Die Probleme von Ketten und Bäumen</span>
      </div>
      <div class="chapter" data-start="2531" data-end="3260">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">42:11</span>
        <span class="chapter-title">Dynamische Felder</span>
      </div>
      <div class="chapter" data-start="3260" data-end="3426.017">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">54:20</span>
        <span class="chapter-title">Die Dominanz dynamischer Felder</span>
      </div>
    </div>
    <section>
      <h3>Download</h3>
      <ul>
          <li><a href="/dl/stp-077-liste-von-listen.mp3">MP3</a> (52,6 MiB)</li>
          <li><a href="/dl/stp-077-liste-von-listen.ogg">Ogg Vorbis</a> (32,2 MiB)</li>
          <li><a href="/dl/stp-077-liste-von-listen.opus">Opus</a> (19,8 MiB)</li>
      </ul>
    </section>
    <section>
      <h3>Shownotes</h3>
      <p><ul>
<li>
<p>Rückbezüge:</p>
<ul>
<li>fundamentale Datenstrukturen siehe STP071: Felder/Listen, <del>assoziative Datenfelder (Maps), Graphen</del></li>
<li>Frage: Wie stellt man solche Datenstrukturen im Speicher dar? Gibt es darauf überhaupt die eine richtige Antwort?</li>
<li>algorithmische Komplexität siehe STP029: Liste mit <code>n</code> Elementen ausdrucken in <code>O(n)</code>, aber sortieren in <code>O(n log(n))</code> bis <code>O(n^2)</code></li>
<li>Speicherallokation siehe STP047 und Speicherschutz siehe STP019: Bezug wird gleich klar werden</li>
</ul>
</li>
<li>
<p>Listen kann man als <a href="https://de.wikipedia.org/w/index.php?title=Liste_(Datenstruktur)&amp;oldid=253638160">verkettete Liste darstellen</a></p>
<ul>
<li>klassisches Studienobjekt in Erstsemester-Datenstrukturen-Vorlesungen</li>
<li>intuitiv verständlich: Parallele zu segmentierten Halsketten</li>
<li>wahlweise einfach oder doppelt verkettet</li>
<li>effiziente Operationen: Einfügen am Ende, Entfernen am Ende</li>
<li>ineffiziente Operationen: Einfügen in der Mitte, Wahlzugriff/Suche</li>
<li><a href="https://en.wikipedia.org/w/index.php?title=Template:List_data_structure_comparison&amp;oldid=1251607720">Vergleichstabelle mit Darstellung der Zeiteffizienz</a></li>
<li>alles in allem durchwachsene Performance -&gt; geht es besser?</li>
</ul>
</li>
<li>
<p>alternative Strategie: interne Darstellung der Liste als <a href="https://de.wikipedia.org/w/index.php?title=Balancierter_Baum&amp;oldid=243407080">balancierter Baum</a> (oder evtl. &quot;ausgeglichener Baum&quot;)</p>
<ul>
<li>außerdem Link auf <a href="https://en.wikipedia.org/w/index.php?title=Self-balancing_binary_search_tree&amp;oldid=1273477858">die englische Wikipedia</a>, die nicht nur unbalancierte, sondern auch balancierte Bäume zeigt</li>
<li>kann nur sortierte Listen darstellen</li>
<li>Idee: Wurzelknoten hat das Median-Element, dann der linke Ast alle kleineren und der rechte Ast alle größeren Elemente</li>
<li>im Grunde alle gängigen Operationen mittelschnell: Wahlzugriff/Suche, Einfügen an beliebigen Stellen, Entfernen von beliebigen Stellen (Änderungen erfordern im Allgemeinen ein Austarieren des Baumes)</li>
<li>große Variation von Implementationsstrategien für dieses Balancieren -&gt; hier nicht</li>
</ul>
</li>
<li>
<p>verkettete Listen und balancierte Bäume sehen auf dem Papier ziemlich effizient aus, haben aber in ihrer reinen Form pathologisch schlechtes Speicherverhalten</p>
<ul>
<li>hoher Platzverbrauch: z.B. bei einfach bzw. doppelt verketteten Listen muss zu jedem Element müssen noch eine bzw. zwei Speicheradressen abgelegt werden</li>
<li>hohe Allokationslast: wenn nicht eine Arena oder ein vergleichbarer Small Object Allocator verwendet wird</li>
<li>schlechte Lokalität: beim Durchlaufen nachfolgender Elemente werden im schlimmsten Fall ständig unterschiedliche Speicherseiten getroffen, was fortlaufend Seitenfehler verursachen kann</li>
</ul>
</li>
<li>
<p>in der Praxis mit Abstand dominante Implementationsstrategie: <a href="https://en.wikipedia.org/w/index.php?title=Dynamic_array&amp;oldid=1268522792">dynamische Felder</a></p>
<ul>
<li>Beobachtung: Einfügen oder Löschen an beliebigen Stellen wird kaum gemacht; man hängt eher mehrmals ans Ende an und sortiert dann, falls nötig</li>
<li>Idee: Optimieren auf Einfügen am Ende bei möglichst optimalen Speicherverhalten</li>
<li>Umsetzung: einfaches Feld (ein fortlaufendes Stück Speicher, in dem mehrere Elemente hintereinander abgelegt werden) mit aktuellem Füllstand N und Kapazität K</li>
<li>Einfügen ans Ende: normalerweise einfach N erhöhen; wenn N nicht in K passt, größeren Speicher reservieren, alles hinüberkopieren und die alten Speicherallokation verwerfen</li>
<li>Löschen vom Ende: einfach N reduzieren, keine Deallokation erforderlich</li>
<li>Einfügen am Anfang oder in die Mitte: alle Elemente dahinter nach hinten verschieben</li>
</ul>
</li>
<li>
<p>nahezu optimales Speicherverhalten von dynamischen Feldern begründet ihre Dominanz</p>
<ul>
<li>Platzverbrauch: neben der Speichergröße der Elemente selber nur zwei Zahlen (N und K)</li>
<li>Allokationslast: Vergrößern geht für gewöhnlich in exponentiellen Schritten und wird damit für wachsende Listen immer seltener nötig</li>
<li>Lokalität: lineare Suche durch die Liste geht linear durch den Speicher hindurch -&gt; folgende Speicherseiten können vom Prozessor oft schon auf Verdacht vorgeladen werden</li>
<li>trotzdem: die anderen Datenstrukturen haben auch ihre Berechtigung (z.B. modifizierte balancierte Bäume als Basis für Datenbank-Indizes)</li>
</ul>
</li>
<li>
<p>Xyrill will auch noch auf analoge Weise über Maps und Graphen reden -&gt; weiter in STP079</p>
</li>
</ul></p>
    </section>
    <section>
      <h3>Audioquellen<span>&nbsp;in Abspielreihenfolge (soweit nicht gemeinfrei)</span></h3>
      <ul>
          <li><a href="https://freesound.org/people/MastersDisaster/sounds/218115/">MastersDisaster: &quot;Switch ON - Livingroom (Sample)&quot;</a></li>
          <li><a href="https://freesound.org/people/Garuda1982/sounds/538915/">Garuda1982: &quot;Switch on the fluorescent tube sound effect&quot;</a></li>
          <li><a href="https://www.youtube.com/watch?v=n8Yo-wD-QTo&amp;t=129s">Konrad Zuse: &quot;HR-Fernsehbericht von 1958&quot;</a></li>
          <li><a href="https://www.youtube.com/watch?v=jbrMBOF61e0&amp;t=9s">Donald Knuth: &quot;Lehrveranstaltung von 1981&quot;</a></li>
      </ul>
    </section>

  <footer class="legal">
    <a href="/legal/de/">Impressum/Datenschutz</a>
  </footer>
  <script async src="/res/chapter-marks.js"></script>
</body>
</html>
