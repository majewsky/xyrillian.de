<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Speicherallokation - Xyrillian Noises</title>
  <link rel="stylesheet" href="/res/xyrillian.css" />
</head>
<body class="noises episode-stp has-nav-top-card">
  <nav class="top-card">
    <div>
      <a href="/noises/">
        <img class="sitelogo" src="/res/logo-noises.svg" alt="Xyrillian Noises Hörfunkproduktion">
      </a>
    </div>
  </nav>
  <header>
    <a class="coverart" href="/noises/stp/">
      <img src="/res/cover-stp.svg" alt="Cover-Art für: Schlüsseltechnologie">
    </a>
    <h2><a href="/noises/stp">Schlüsseltechnologie</a> #47 vom 30. November 2023</h2>
    <h1>Speicherallokation</h1>
      <p>Ein weiteres Mal beschäftigen wir uns mit Speicher. Diesmal spezifisch mit Haufen davon. Wie man die wieder wegräumt oder gar nicht erst zu groß werden lässt, ist auch ein Thema. Außerdem gibt es ein Novum direkt am Beginn der Folge.</p>
      <p><strong>Länge:</strong> 68:54 Minuten</p>
  </header>
    <audio controls preload="none">
        <source src="/dl/stp-047-speicherallokation.mp3" type="audio/mpeg">
        <source src="/dl/stp-047-speicherallokation.ogg" type="audio/ogg">
        <source src="/dl/stp-047-speicherallokation.opus" type="audio/opus">
      <div class="audio-not-supported">
        <span>Webplayer nicht vom Browser unterstützt</span>
      </div>
    </audio>
    <div id="chapters">
      <div class="chapter" data-start="0" data-end="217">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">00:00</span>
        <span class="chapter-title">CTA, Intro und Prolog</span>
      </div>
      <div class="chapter" data-start="217" data-end="362">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">03:37</span>
        <span class="chapter-title">Rückbezug auf STP045</span>
      </div>
      <div class="chapter" data-start="362" data-end="385">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">06:02</span>
        <span class="chapter-title">Das Grundproblem</span>
      </div>
      <div class="chapter" data-start="385" data-end="473">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">06:25</span>
        <span class="chapter-title">Abschweif: Notizen für die Klausur</span>
      </div>
      <div class="chapter" data-start="473" data-end="557">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">07:53</span>
        <span class="chapter-title">Man braucht einen Allokator</span>
      </div>
      <div class="chapter" data-start="557" data-end="1283">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">09:17</span>
        <span class="chapter-title">malloc und free</span>
      </div>
      <div class="chapter" data-start="1283" data-end="1311">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">21:23</span>
        <span class="chapter-title">Fehlerquellen in der Speicherverwaltung</span>
      </div>
      <div class="chapter" data-start="1311" data-end="1533">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">21:51</span>
        <span class="chapter-title">Speicherleck</span>
      </div>
      <div class="chapter" data-start="1533" data-end="1847">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">25:33</span>
        <span class="chapter-title">Pufferüberlauf</span>
      </div>
      <div class="chapter" data-start="1847" data-end="2082">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">30:47</span>
        <span class="chapter-title">Use after free</span>
      </div>
      <div class="chapter" data-start="2082" data-end="2760">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">34:42</span>
        <span class="chapter-title">Automatische Speicherverwaltung</span>
      </div>
      <div class="chapter" data-start="2760" data-end="3113">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">46:00</span>
        <span class="chapter-title">Mark and Sweep</span>
      </div>
      <div class="chapter" data-start="3113" data-end="3644">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">51:53</span>
        <span class="chapter-title">Optimierung der Heap-Nutzung</span>
      </div>
      <div class="chapter" data-start="3644" data-end="4134.657">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">60:44</span>
        <span class="chapter-title">Caching</span>
      </div>
    </div>
    <section>
      <h3>Download</h3>
      <ul>
          <li><a href="/dl/stp-047-speicherallokation.mp3">MP3</a> (63,4 MiB)</li>
          <li><a href="/dl/stp-047-speicherallokation.ogg">Ogg Vorbis</a> (39,8 MiB)</li>
          <li><a href="/dl/stp-047-speicherallokation.opus">Opus</a> (23,7 MiB)</li>
      </ul>
    </section>
    <section>
      <h3>Shownotes</h3>
      <p><ul>
<li>
<p>Rückbezug auf STP045: <strong>Heap</strong> (Haufenspeicher)</p>
<ul>
<li>keine Strukturvorgaben durch das Betriebssystem oder die Prozessorarchitektur</li>
<li>notwendig für Daten, deren Lebenszeit nicht der Struktur von Unterprogrammen folgt, oder deren Größe die 132 KiB des Stacks übersteigt</li>
<li>neue Frage: Wie kann man diesen unstrukturierten Haufen sinnvoll verwalten?</li>
<li>Analogie: Ein Team verwendet als Speicher ein großes Whiteboard, auf dem verschiedene Mitglieder des Teams rumschreiben wollen, ohne sich gegenseitig in die Quere zu kommen.</li>
</ul>
</li>
<li>
<p>man braucht einen <a href="https://de.wikipedia.org/w/index.php?title=Allokation_(Informatik)&amp;oldid=199910001">Allokator</a></p>
<ul>
<li>meist in Form einer Programmbibliothek, die auf die jeweilige Programmiersprache und/oder Laufzeitumgebung abgestimmt ist</li>
<li>klassischerweise zwei Funktionen: &quot;malloc&quot; (&quot;memory allocate&quot;; ich brauche ein Stück Speicher der Größe X) und &quot;free&quot; (das gegebene Stück Speicher brauche ich nicht mehr)</li>
<li>Allokationen mittels malloc sind meist sehr viel kleiner als die Speicherseiten, die das Betriebssystem rausgibt (min. 4 KB) -&gt; Allokator holt sich ganze Speicherseiten und zerteilt die in mundgerechte Stücke</li>
<li>damit &quot;free&quot; funktioniert, muss der Allokator irgendwo über diese Zerstückelung Buch führen -&gt; gewisser Mehraufwand an Speicher für die Buchführung</li>
<li>verschiedene Anwendungen machen ihre Speicherallokationen in unterschiedlichen Mustern (häufig z.B. ein gewisser Bodensatz an großen Allokationen, die für die ganze Lebensdauer des Programms erhalten bleiben, und dazu sehr viele kleine und kurzlebige Allokationen für bestimmte Einzeloperationen) -&gt; interessantes Arbeits- und Forschungsfeld für Leute, die sich gern in Algorithmen eingraben</li>
</ul>
</li>
<li>
<p>Speicherverwaltung im Heap ist sicherheitskritisch -&gt; mögliche Fehlerquellen</p>
<ul>
<li>Speicherleck: Speicher wird allokiert, aber dann nicht wieder freigegeben; da der Allokator nicht wissen kann, ob der Speicher noch verwendet wird, muss er brachliegen</li>
<li><a href="https://de.wikipedia.org/w/index.php?title=Puffer%C3%BCberlauf&amp;oldid=236800782">Pufferüberlauf</a>: Allokation war für X Bytes, aber dann wird über das Ende (Basisadresse + X) hinausgeschrieben; dies zerstört dann Daten in anderen Allokationen oder Buchführungsdaten des Allokators</li>
<li><a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory">Use after free</a>: Allokation wird mit &quot;free&quot; zurückgegeben, aber danach noch vom Programm verwendet, obwohl der Allokator dieses Stück Speicher vielleicht schon wieder anderweitig allokiert hat</li>
<li>Das klingt alles anstrengend. Kann man das nicht den Computer machen lassen? -&gt; <strong>automatische Speicherverwaltung</strong></li>
</ul>
</li>
<li>
<p>einfachste praktikable Idee: <a href="https://de.wikipedia.org/w/index.php?title=Referenzz%C3%A4hlung&amp;oldid=221346853">Referenzen zählen</a></p>
<ul>
<li>Ansatz: bei allokiertem Speicher nicht die lose Speicheradresse herumreichen, sondern noch einen Zähler mitführen
<ul>
<li>Zähler beginnt bei 1, da man am Anfang eine Referenz hat</li>
<li>bei jedem Kopieren der Referenz wird der Zähler um 1 erhöht, bei jedem Löschen einer Referenz um 1 verringert</li>
<li>die Allokation wird freigegeben, wenn der Zähler auf 0 fällt</li>
</ul>
</li>
<li>Vorteil: sehr schnell, sehr zuverlässig, eliminiert bei konsequenter Anwendung das Risiko von &quot;Use after free&quot;</li>
<li>Nachteil: garantierte Speicherlecks bei zyklischen Referenzen (z.B. A verweist auf B verweist auf C verweist auf A, aber nichts anderes verweist auf A/B/C)</li>
<li>komplexere Formen von automatische Speicherverwaltung mit Zykluserkennung heißen meist <a href="https://de.wikipedia.org/w/index.php?title=Garbage_Collection&amp;oldid=236166816">Garbage Collector</a> (GC, &quot;Müllsammler&quot;); strenggenommen sind Referenzzähler &quot;konservative GC&quot;</li>
</ul>
</li>
<li>
<p>Beispiel für einen GC-Algorithmus: <strong>Mark and Sweep</strong></p>
<ul>
<li>aktives Aufräumen zu bestimmten Gelegenheiten, z.B. wenn bei malloc kein Speicher mehr frei ist und weiterer Speicher vom Betriebssystem angefordert werden müsste</li>
<li>Algorithmus:
<ul>
<li>Allokationen, deren Adressen im Stack liegen, werden als &quot;erreichbar&quot; markiert</li>
<li>alle anderen Allokationen werden initial als &quot;nicht erreichbar&quot; markiert</li>
<li>ausgehend von den erreichbaren Allokationen wird sukzessive nach Verweisen auf andere Allokationen gesucht und diese ebenfalls als &quot;erreichbar&quot; markiert</li>
<li>nachdem alles durchsucht wurde, werden alle Allokationen freigegeben, die immer noch als &quot;nicht erreichbar&quot; markiert sind</li>
</ul>
</li>
<li>GC braucht meist eine enge Integration mit dem Allokator und mit der Programmiersprache oder der Laufzeitumgebung (z.B. insb. um die Frage &quot;welche Allokationen sind im Stack referenziert&quot; zu beantworten)</li>
<li>Nachteil: fast jeder GC muss zumindest für einen Teil der Aufräumphase &quot;die Welt anhalten&quot;, was für den Nutzer wie Motorstottern aussieht</li>
</ul>
</li>
<li>
<p>Optimierung der Heap-Nutzung: Anzahl der Allokationen verringern (es gilt die Faustregel &quot;der einzige Weg, zu optimieren, ist, weniger zu tun&quot;)</p>
<ul>
<li>zusammenhängende Datenstrukturen möglichst in eine einzelne Allokation ablegen anstatt in mehrere Teilstücke (&quot;Arena-Allokation&quot;, &quot;Small Object Allocation&quot;)</li>
<li>kleine Daten bevorzugt im Stack halten und nicht auf den Heap legen (Xyrill hat eine Anekdote zu Minecraft)</li>
<li>noch eine Idee: GC zu opportunen Momenten explizit anstarten (z.B. bei Spielen während des VSync, d.h. wenn ein Einzelbild gerade fertig ist und es auf den Bildschirm kopiert wird)</li>
</ul>
</li>
<li>
<p>zum Schluss ein Blick auf ein Teilgebiet der Heap-Algorithmen: <a href="https://de.wikipedia.org/w/index.php?title=Cache&amp;oldid=236047086">Zwischenspeicher (Cache)</a></p>
<ul>
<li>Grundproblem: bestimmte Operationen sind teuer (z.B. Netzwerkabfragen, Einlesen von Dateien von der Festplatte, komplexe Berechnungen), aber reproduzierbar; wir würden die Ergebnisse gerne wiederverwenden, aber können nicht alle im Speicher halten</li>
<li>Speicherstück mit einer festen Größe wird als Cache designiert</li>
<li>idealerweise würde man genau die Ergebnisse dort ablegen, die in der Zukunft am häufigsten wieder nachgefragt werden</li>
<li>Problem: <a href="https://en.wikiquote.org/w/index.php?title=Niels_Bohr&amp;oldid=3344877">&quot;Vorhersagen sind schwierig, insbesondere, wenn sie die Zukunft betreffen&quot;</a> -&gt; Cache-Replacement-Algorithmen sind ein Forschungsfeld</li>
<li>Beispiel <strong>LRU</strong> (&quot;Least Recently Used&quot;): wenn ein neues Element abgelegt wird, wird dasjenige existierende Element überschrieben, das am längsten ungenutzt ist</li>
</ul>
</li>
<li>
<p>Lesestoff: <a href="https://www.memorymanagement.org/">www.memorymanagement.org</a> (englisch)</p>
</li>
</ul></p>
    </section>
    <section>
      <h3>Audioquellen<span>&nbsp;in Abspielreihenfolge (soweit nicht gemeinfrei)</span></h3>
      <ul>
          <li><a href="https://freesound.org/people/MastersDisaster/sounds/218115/">MastersDisaster: &quot;Switch ON - Livingroom (Sample)&quot;</a></li>
          <li><a href="https://freesound.org/people/Garuda1982/sounds/538915/">Garuda1982: &quot;Switch on the fluorescent tube sound effect&quot;</a></li>
          <li><a href="https://www.youtube.com/watch?v=n8Yo-wD-QTo&amp;t=129s">Konrad Zuse: &quot;HR-Fernsehbericht von 1958&quot;</a></li>
          <li><a href="https://www.youtube.com/watch?v=jbrMBOF61e0&amp;t=9s">Donald Knuth: &quot;Lehrveranstaltung von 1981&quot;</a></li>
      </ul>
    </section>

  <footer class="legal">
    <a href="/legal/de/">Impressum/Datenschutz</a>
  </footer>
  <script async src="/res/chapter-marks.js"></script>
</body>
</html>
