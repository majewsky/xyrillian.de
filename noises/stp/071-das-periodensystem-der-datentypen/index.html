<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Das Periodensystem der Datentypen - Xyrillian Noises</title>
  <link rel="stylesheet" href="/res/xyrillian.css" />
</head>
<body class="noises episode-stp has-nav-top-card">
  <nav class="top-card">
    <div>
      <a href="/noises/">
        <img class="sitelogo" src="/res/logo-noises.svg" alt="Xyrillian Noises Hörfunkproduktion">
      </a>
    </div>
  </nav>
  <header>
    <a class="coverart" href="/noises/stp/">
      <img src="/res/cover-stp.svg" alt="Cover-Art für: Schlüsseltechnologie">
    </a>
    <h2><a href="/noises/stp">Schlüsseltechnologie</a> #71 vom 17. April 2025</h2>
    <h1>Das Periodensystem der Datentypen</h1>
      <p>Offenbar gibt es unterschiedliche Ergebnisse, wenn verschiedene Datentypen für die gleichen Dinge verwendet werden. Wir fangen heute mal damit an, zu verstehen, welche Datentypen es denn überhaupt gibt. Außerdem geht es scheinbar um Kaffee und Rost.</p>
      <p><strong>Länge:</strong> 62:01 Minuten</p>
  </header>
    <audio controls preload="none">
        <source src="/dl/stp-071-das-periodensystem-der-datentypen.mp3" type="audio/mpeg">
        <source src="/dl/stp-071-das-periodensystem-der-datentypen.ogg" type="audio/ogg">
        <source src="/dl/stp-071-das-periodensystem-der-datentypen.opus" type="audio/opus">
      <div class="audio-not-supported">
        <span>Webplayer nicht vom Browser unterstützt</span>
      </div>
    </audio>
    <div id="chapters">
      <div class="chapter" data-start="0" data-end="303">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">00:00</span>
        <span class="chapter-title">Postkarte aus Potsdam</span>
      </div>
      <div class="chapter" data-start="303" data-end="564">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">05:03</span>
        <span class="chapter-title">Intro</span>
      </div>
      <div class="chapter" data-start="564" data-end="844">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">09:24</span>
        <span class="chapter-title">Serialisierung und JSON</span>
      </div>
      <div class="chapter" data-start="844" data-end="1106">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">14:04</span>
        <span class="chapter-title">Softwaredesign</span>
      </div>
      <div class="chapter" data-start="1106" data-end="2232">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">18:26</span>
        <span class="chapter-title">Atomare Datentypen</span>
      </div>
      <div class="chapter" data-start="2232" data-end="2889">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">37:12</span>
        <span class="chapter-title">Abgeleitete Datentypen: Listen</span>
      </div>
      <div class="chapter" data-start="2889" data-end="3200">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">48:09</span>
        <span class="chapter-title">Abgeleitete Datentypen: Assoziative Datenfelder</span>
      </div>
      <div class="chapter" data-start="3200" data-end="3721.208">
        <div class="chapter-progress"><div class="chapter-progress-filler">&nbsp;</div></div>
        <span class="chapter-start" title="Zur Kapitelmarke springen">53:20</span>
        <span class="chapter-title">Was JSON nicht kann</span>
      </div>
    </div>
    <section>
      <h3>Download</h3>
      <ul>
          <li><a href="/dl/stp-071-das-periodensystem-der-datentypen.mp3">MP3</a> (57,1 MiB)</li>
          <li><a href="/dl/stp-071-das-periodensystem-der-datentypen.ogg">Ogg Vorbis</a> (35,4 MiB)</li>
          <li><a href="/dl/stp-071-das-periodensystem-der-datentypen.opus">Opus</a> (21,4 MiB)</li>
      </ul>
    </section>
    <section>
      <h3>Shownotes</h3>
      <p><ul>
<li>
<p><a href="https://de.wikipedia.org/w/index.php?title=JavaScript_Object_Notation&amp;oldid=249644714">JSON</a>: ein populäres Format für die Serialisierung von Daten</p>
<ul>
<li><a href="https://de.wikipedia.org/w/index.php?title=Serialisierung&amp;oldid=241468956">Serialisierung</a>: &quot;Abbildung von strukturierten Daten auf eine sequenzielle Darstellungsform&quot;, insb. auf Bytefolgen wie in einer Datei oder einer Datenübertragung im Netzwerk</li>
<li>JSON ist bekannt dafür, nicht erfunden, sondern &quot;entdeckt&quot; worden zu sein
<ul>
<li><a href="https://www.corecursive.com/json-vs-xml-douglas-crockford/">https://www.corecursive.com/json-vs-xml-douglas-crockford/</a></li>
</ul>
</li>
<li>außerdem relativ minimal: nur sechs verschiedene Grundstrukturen</li>
<li>aber trotzdem relativ universell: damit unser Ausgangspunkt für die Kartografierung der Welt der Datentypen</li>
<li>außerdem Gegenüberstellung mit dem Typvorrat von Rust (einer zeitgenössischen Programmiersprache mit einem detaillierten Typsystem)</li>
</ul>
</li>
<li>
<p>atomare Datentypen: einzelne Werte (C++ nennt sie &quot;Plain Old Data&quot; (POD), Perl nennt sie &quot;Skalare&quot;)</p>
<ul>
<li>Boolean: ein Bit (wahr oder falsch)
<ul>
<li>Typvorrat in Rust: <code>bool</code></li>
<li>in JSON: <code>true</code> oder <code>false</code></li>
</ul>
</li>
<li>Zahlen: in verschiedenen Bitgrößen, mit oder ohne Vorzeichen, Ganzzahl oder Fließkommazahl
<ul>
<li>Typvorrat in Rust: <code>u8/i8, u16/i16, u32/i32, u64/i64, u128/i128, usize/isize, f32, f64</code></li>
<li>in JSON: wie gewohnt ausgeschrieben (z.B. <code>42</code>, <code>-23.5</code>) oder in wissenschaftlicher Notation (z.B. <code>7.297e-3</code> oder <code>-6.022E23</code>)</li>
</ul>
</li>
<li>Zeichenfolgen: nicht wirklich unteilbar, aber wird für gewöhnlich als einzelner Wert verstanden
<ul>
<li>Typvorrat in Rust: <code>String</code> (UTF-8), <code>OsString</code> (Kodierung gemäß Zeichentabelle des Systems) und andere</li>
<li>in JSON: als Zeichenkette mit Anführungszeichen und mit Escape-Sequenzen für nicht druckbare Zeichen (z.B. <code>&quot;Mit freundlichen Grüßen\nErika Mustermann&quot;</code>)</li>
</ul>
</li>
<li>fehlender Wert: in JSON <code>null</code> (heißt woanders vielleicht auch <code>nil</code>)
<ul>
<li>Typvorrat in Rust: siehe später</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Listen: ein abgeleiteter Datentyp</p>
<ul>
<li>deswegen vorhin &quot;atomar&quot;: der Typ einer Liste bestimmt sich aus dem Typ der Elemente (in statisch typisierten Programmiersprachen ist z.B. &quot;Liste von 8-Bit-Zahlen&quot; etwas anderes als &quot;Liste von Strings&quot; oder &quot;Liste von Listen von Strings&quot;)</li>
<li>Typvorrat in Rust:
<ul>
<li>mit variabler Länge: <code>Vec&lt;X&gt;</code>, wobei <code>X</code> für den Typ der Elemente steht (Beispiele zu oben: <code>Vec&lt;u8&gt;</code>, <code>Vec&lt;String&gt;</code>, <code>Vec&lt;Vec&lt;String&gt;&gt;</code>); der Name &quot;Vec&quot; deutet auf die Struktur im Arbeitsspeicher hin</li>
<li>mit fester Länge: <code>[X; N]</code>, wobei <code>N</code> für die Anzahl von Elementen steht</li>
</ul>
</li>
<li>in JSON: kommagetrennte Liste der Elemente in eckigen Klammern (z.B. <code>[42, 23]</code>)</li>
<li>Unterschiede zu Rust:
<ul>
<li>JSON ist nicht statisch typisiert und hat nur einen Listentyp, der alle möglichen Elemente enthalten kann und beliebig lang sein kann (z.B. <code>[42, &quot;Hallo&quot;, []]</code>)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>assoziative Datenfelder: ein anderer abgeleiteter Datentyp</p>
<ul>
<li>enthält nicht einzelne Elemente, sondern Paare von Schlüssel und Wert; ermöglicht schnellen Zugriff auf einen Wert anhand seines Schlüssels</li>
<li>heißt je nach Programmiersprache bzw. Datenformat &quot;Objekt&quot;, &quot;Map&quot;, &quot;Dictionary&quot; etc.</li>
<li>Typvorrat in Rust: unter anderem <code>HashMap&lt;K, V&gt;</code>, wobei <code>K</code> der Schlüsseltyp (&quot;key&quot;) und <code>V</code> der Werttyp (&quot;value&quot;) ist; der Name &quot;HashMap&quot; deutet auf die Struktur im Arbeitsspeicher hin</li>
<li>in JSON: kommagetrennte Liste von Wertpaaren in geschweiften Klammern, die Wertpaare jeweils mit Doppelpunkt getrennt; der Schlüssel muss ein String sein (z.B. <code>{&quot;Karo&quot;: 9, &quot;Herz&quot;: 10, &quot;Pik&quot;: 11, &quot;Kreuz&quot;: 12}</code>)</li>
<li>wiederum Unterschied zu Rust: Werte verschiedener Typen dürfen gemischt werden</li>
</ul>
</li>
<li>
<p>Damit ist alles beschrieben, was JSON kann, doch es gibt so viel mehr! Beispiele für abgeleitete Datentypen:</p>
<ul>
<li>Mengen (&quot;Sets&quot;): wie Listen, aber ohne definierte Ordnung
<ul>
<li>in Rust: <code>HashSet&lt;X&gt;</code>; der Name &quot;HashSet&quot; deutet auf die Struktur im Arbeitsspeicher hin</li>
</ul>
</li>
<li>Graphen: Netzwerke von Knoten mit Kanten dazwischen (z.B. Straßenkarte: Kreuzungen = Knoten, Straßen = Kanten)
<ul>
<li>in Rust: kein entsprechender Typ in der Standardbibliothek</li>
<li>ähnlich wie bei Listen und assoziativen Datenfeldern viele verschiedene Implementationsstrategien, aber bei Graphen gibt es keinen &quot;Standardansatz&quot;</li>
</ul>
</li>
<li>Außerdem ist JSON relativ restriktiv in der Auswahl an PODs. Andere Serialisierungsformate unterstützen zum Beispiel Datums- oder Zeitangaben, Referenzen auf externe Dateien etc.</li>
</ul>
</li>
<li>
<p>im Gespräch erwähnt</p>
<ul>
<li>Hörtipp: <a href="https://www.corecursive.com/json-vs-xml-douglas-crockford/">Douglas Crockford bei CoRecursive zur Entstehung von JSON</a></li>
<li>Lehrbuch: <a href="https://en.wikipedia.org/w/index.php?title=Structure_and_Interpretation_of_Computer_Programs&amp;oldid=1244483390">Structure and Interpretation of Computer Programs</a></li>
</ul>
</li>
</ul></p>
    </section>
    <section>
      <h3>Audioquellen<span>&nbsp;in Abspielreihenfolge (soweit nicht gemeinfrei)</span></h3>
      <ul>
          <li><a href="https://freesound.org/people/MastersDisaster/sounds/218115/">MastersDisaster: &quot;Switch ON - Livingroom (Sample)&quot;</a></li>
          <li><a href="https://freesound.org/people/Garuda1982/sounds/538915/">Garuda1982: &quot;Switch on the fluorescent tube sound effect&quot;</a></li>
          <li><a href="https://www.youtube.com/watch?v=n8Yo-wD-QTo&amp;t=129s">Konrad Zuse: &quot;HR-Fernsehbericht von 1958&quot;</a></li>
          <li><a href="https://www.youtube.com/watch?v=jbrMBOF61e0&amp;t=9s">Donald Knuth: &quot;Lehrveranstaltung von 1981&quot;</a></li>
      </ul>
    </section>

  <footer class="legal">
    <a href="/legal/de/">Impressum/Datenschutz</a>
  </footer>
  <script async src="/res/chapter-marks.js"></script>
</body>
</html>
